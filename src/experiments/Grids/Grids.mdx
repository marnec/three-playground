import SnappyGrid from './SnappyGrid.tsx';
import LerpGrid from './LerpGrid.tsx';
import Raycasting from './Raycasting.tsx';
import ExperimentSceneWrapper from '../../components/ExperimentSceneWrapper.tsx';


<ExperimentSceneWrapper>
    <LerpGrid />
</ExperimentSceneWrapper>

Grids are useful, especially if you need to draw at screen something that users will have to 
manipulate with a certain degree of precision. It can act as a visual cue or it can be used 
to effetcively constraint the movement of objects on a surface.

Three js has a useful `GridHelper` that lets you draw a grid on the plane $\mathcal{P}_{xz}$. 
[Drei](https://drei.docs.pmnd.rs/) expands on that with some useful features like the ability
to draw an inifinite grid or make the grid follow the camera.

Let's say that we want a cube to follow our cursor position, but only move at grid intersections.
To achieve that we need to: (a) Track the position of the cursor on the plane; (b) Calculate the
closest grid intersection point $p$; (c) Set the position of the cube to $p$.

Tracking the position of the cursor on the plane is achieved through a tool commonly used in 
3D grahics, a `Raycaster`. A raycaster is an object that casts a "ray" from point `A` to `B`.
In our case, we want to cast a ray from the `Camera` (our point of view) to the grid. 

Once that is done, we can retrieve the position in world coordinates where the ray intersected
with the plane.

<ExperimentSceneWrapper className='mt-5'>
    <Raycasting />
</ExperimentSceneWrapper>

We can use these coordiantes to update the position of an object. Restraining the object position
to grid intersections becomes trival, at every frame we need to compute:

$$
\begin{aligned}
x = & \nint{x / s} \cdot s \\
z = & \nint{z / s} \cdot s \\
\end{aligned}
$$

Where $s$ is the size of the grid section or in other words the *step* of the grid.

This means that, at every frame, we are rounding the position to the nearest grid intersection.
This creates a snappy behaivour, where the moved object (a box in this case) jumps from a position to
the next one.

<ExperimentSceneWrapper className='mt-5'>
    <SnappyGrid />
</ExperimentSceneWrapper>

---

An improvement over this snappy behavior is to smooth the motion between grid positions. We can
achieve this using linear interpolation, commonly called `lerp`.

Given two points $A$ and $B$, linear interpolation computes a point $C$ along the segment $\overline{AB}$:

$$
\begin{aligned}
\text{lerp}(A, B, \alpha) & = A + (B - A) \cdot \alpha \\
& = (1 - \alpha) \cdot A + \alpha \cdot B
\end{aligned}
$$

The parameter $\alpha \in [0, 1]$ controls how far $C$ lies along the segment: when $\alpha = 0$,
we get $C = A$; when $\alpha = 1$, we get $C = B$.

When you apply lerp repeatedly at each frame let's say with $\alpha=0.15$, you are doing something like:

> Move 15% of the remaining distance to the target each frame

This creates exponential decay toward the target and gives a springy feels to the motion. However it's 
important to notice that this approach is not a physics simulation. It's more a low-pass filter than 
anything else: we are **filtering the position signal**, taking the current value $A$ and blendng 
it a *little* ($\alpha$) towards the target value $B$.

<ExperimentSceneWrapper>
    <LerpGrid />
</ExperimentSceneWrapper>

---

If we apply linear interpolation naively at every frame, we are doing frame-dependent interpolation, which
is usually not what you want. The simulation should run independently from the ability of the renderer
to draw at screen. If we use a fixed $\alpha$, the object will move faster on a machine running at 120 FPS
than on one running at 30 FPS, since more lerp steps are executed per second.

The most common solution to this problem is to add a factor $\delta$ (or $dt$), which is effectively the
seconds passed between the previous and current frame.

$$
\text{lerp}(a, b, k) = a + (b - a) \cdot k \cdot \delta
$$

And this is also where I would stop if it wasn't for [gingerBill video at BSC2025](https://www.youtube.com/watch?v=YNtoDGS4uak).
In that video I discovered that this common solution helps but it's still slightly frame-rate dependent.

It helps because when the frame rate drops, $\delta$ increases, so we take a larger step to compensate.
However, this solution is still slightly frame rate dependent because lerp is inherently non-linear when
applied repeatedly: the step size depends on the current distance to the target, which changes after each
frame. A more frame independent solution is instead:

$$
\text{lerp}(a, b, k) = a + (b - a) \cdot (1 - e^{-k \delta})
$$

To explain where the term $1 - e^{-k \delta}$ comes from, we need to look more closely
at our attempt at a frame independent lerp $a + (b - a) \cdot k \cdot \delta$. What we are doing
here is saying that the source point $a$ should move towards the target point $b$ by a certain
amount $\Delta{a}$. This amount is the distance from the current value $a(t)$ to $b$, scaled by a factor
$k$ and scaled again by the time that passed $\Delta{t}$:

Note that $k$ is no longer a fraction like $\alpha$ was. The value of the lerp factor is no more bound
in the $[0,1]$ interval and doesn't represent anymore percentage displacement towards target. 
It's now a *decay rate* with units of 1/second, and can be any positive number. 
A higher $k$ means faster convergence:  

$$
\Delta{a}  = (b - a(t)) \cdot k \cdot \Delta{t}
$$

We can rearrange this to express the rate of change. By dividing both sides by $\Delta{t}$ and taking the
limit as the time interval becomes infinitesimally small, we get a differential equation:

$$
\begin{aligned}
& \frac{\Delta{a}}{\Delta{t}}  = (b - a(t)) \cdot k  \\
& \frac{da}{dt}  = (b - a(t)) \cdot k  \\
\end{aligned}
$$

This is a first order linear ordinary (rather than partial) differential equation. It says that the rate
of change of $a$ is proportional to how far $a$ is from the target $b$. If you integrate this
differential equation (or you can plug it into [Wolfram Alpha](https://www.wolframalpha.com/input?i=da%2Fdt+%3D+%28b-a%28t%29%29+*+k))
you'll get:


$$
a(t) = b + c_1 \cdot e^{-k t}
$$

Where $c_1$ is a constant determined by the initial conditions. If we know that $a(0) = a_0$ (our starting
position), we can solve for $c_1$: plugging $t = 0$ into the equation gives $a_0 = b + c_1 \cdot e^0 = b + c_1$,
so $c_1 = a_0 - b$.

This solution is fine in continuous time, but when we run a simulation we can only compute at discrete time
intervals (each frame). We need to gradually increment the value of $a$ towards $b$ at each iteration. Let's
substitute our expression for $c_1$ back into the solution and rearrange it into a form that looks more like
a lerp:

$$
\begin{aligned}
a(t) & = b + (a(0) - b) \cdot e^{-k t} \\
a(t) & = a(0) \cdot e^{-k t} + b \cdot (1 - e^{- k t}) \\
a(t) & = a(0) + (b - a(0)) \cdot (1 - e^{- k t})
\end{aligned}
$$

The last line is exactly the lerp formula $\text{lerp}(a(0), b, 1 - e^{-k t})$. So we've circled back to
linear interpolation, but now the interpolation parameter is $(1 - e^{-k t})$ instead of a constant $k$.

This gives us the position at any time $t$ given the initial position $a(0)$. But in a threejs frame (or in a game loop), we don't
have access to the original starting position from time zero; we only know the current position and want to
compute where we'll be after one frame. To get an incremental update formula, we can think of each frame as
starting fresh: the "initial" position is wherever we are now, and $t$ becomes the time step $\Delta{t}$.

$$
a_{\text{next}} = a_{\text{current}} + (b - a_{\text{current}}) \cdot (1 - e^{-k \Delta{t}})
$$

Or equivalently, the change in position each frame is:

$$
\Delta{a} = (b - a) \cdot (1 - e^{-k \Delta{t}})
$$

This is our frame-rate independent lerp. The exponential term $(1 - e^{-k \Delta{t}})$
automatically adjusts for variable frame times: when $\Delta{t}$ is large (low FPS), the exponential term grows
and we take a bigger step; when $\Delta{t}$ is small (high FPS), we take many smaller steps. But unlike the
naive $k \cdot \delta$ approach, this correctly accounts for the compounding nature of the interpolation
and produces the same result regardless of frame rate.

In the code above, you might have noticed the lerp factor is written as:

```ts
const lerpFactor = 1 - Math.pow(0.0001, delta);
```

This looks different from the $1 - e^{-k \Delta t}$ we derived, but they're actually equivalent. Using the
identity $x = e^{\ln(x)}$, we can rewrite the base form:

$$
0.0001^{\delta} = e^{\ln(0.0001) \cdot \delta} = e^{-9.21 \cdot \delta}
$$

So `Math.pow(0.0001, delta)` is the same as $e^{-9.21 \cdot \delta}$, meaning our code uses $k \approx 9.21$.

The two forms offer different ways to think about the speed parameter:

- **Decay rate form** ($1 - e^{-k \Delta t}$): You specify how fast you converge. Higher $k$ means faster movement.
- **Remaining fraction form** ($1 - \text{base}^{\Delta t}$): You specify what fraction of the distance remains after one second.

The second form is often more intuitive for tweaking. With a base of `0.0001`, after one second only 0.01% of the
original distance remains â€” you're essentially there. If you wanted slower, smoother movement, you'd use a larger
base like `0.1`, meaning 10% of the distance remains after one second.