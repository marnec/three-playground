import SinWaveGrid from "./SinWaveGrid"
import SinWavePlane from "./SinWavePlane"
import ExperimentScene from '../../components/ExperimentScene.tsx'
import SinWaveBox from './SinWaveBox.tsx'


<ExperimentScene fullWidth={true}>
  <SinWavePlane />
</ExperimentScene>

I was always fascinated by wave-like motion. I find it calming and
hypnotic.

I knew that to achieve a wave-like effect I would have to use a wave
function somewhere, the first that comes to mind is the sine function
$\sin(\alpha)$. Since $\alpha$ is an angle, its value is expected to be
$0 < \alpha < 2\pi$, but I don't really care about it being an angle,
I only care about the fact that this function returns values in the form
of an infinitely cyclical wave for increasing values of $\alpha$.

This means that I can use this values to set the height of some visual
elements so that they resemble a wave pattern.

The first strategy that came to my mind was to just draw an $n$ by $n$ grid of
simple objects, in this case they are spherical meshes. I didn't bother
with instantiation for performance optimization, they are just a bunch
of spherical geometry meshes placed in a grid.
Then I recentered the grid by translating all mesh coordinates by $-n/2$.

At this point I knew that I needed to set the $y$ coordinate as the
value of $\sin(\alpha)$ using the distance from the center as my $\alpha$.
This only works because the grid is centered on the origin.

<ExperimentScene>
  <SinWaveGrid isAnimated={1} />
</ExperimentScene>

Now it's time to animate the motion. The animation is just based on
elapsed time $t$. The $y$ coordinate is computed at every frame as the
sine of $t$ plus euclidan distance $d$ from the center $d=\sqrt{x^2 + z^2}$.

$$
y = \sin(d + t)
$$

The distance from center provides the initial position and doesn't
change along time, but $t$ keeps increasing moving every single
mesh up and down with the values of the sine function.

---

The actual result I wanted to get to was to animate a surface in a
similar way. I created a mesh and given it a `PlaneGeometry` with
50 segments on both axes. By default, `PlaneGeometry`s are created
on the $[xy]$ so I rotated it by $\pi/2$ radians along the $x$ axis.

Now I needed to do something similar to what I did for the vertical position
of spheres to the vertical position of vertex.

<ExperimentScene>
  <SinWavePlane />
</ExperimentScene>

It was a bit of a pain to understand how to modify the position of vertices
in a `BufferGeometry` because it required to extract the coordinates as
`BufferAttribute`s. From what I can gather threejs now always stores
geometries as buffer geometries, that are based on a more efficient data but
harder to handle data structure.

---

While trying to animate the plane geometry, I noticed in the threejs documentation
that there was a bunch of other geometries and so I wandered if I could apply the
wave motion to a face of a 3d geometry.

I chose arguably the simplest 3d geometry: `BoxGeometry`. I tried to apply the same
principle used for the `PlaneGeometry` but I found out that they are organized in a 
different way: the vertices are stored in a single array of flat coordinates as for
the `PlaneGeometry`, but each face of the cube is assigned to a different `group`, 
each storing the range of indexes that belong to that `group` (and thus that face).

<ExperimentScene> 
  <SinWaveBox />
</ExperimentScene>